# 概要

- 日時 2016/12/10 13:00-17:00
- 場所 横浜ブルーアベニュー 12F 会議室2
- 開始 p.17 1.4 GIFアニメーション
- 終了 p.55 2.7 スコープ
- 議事 浜野（柴田）
- 次回日時 2017/1/14 13:00-17:00


# 参加者

> 高橋 加藤 相田      神保 今井
>                          井上
>                          太田
> 浜野 柴田 吉川      長友 谷澤


# 時間

- 13:00-17:00 輪読


# go

## go 1.8

年始あたりにgo1.8がリリース予定

- エイリアス機能
- プラグイン
- ssa
- gcで止まる時間が短くなる


## go trace

プロファイルを取得するする場合

以下のコードを動かして、標準出力を保存(ここではtrace.out)
```
trace.Start(os.Stdout)
// ここのtrace内容
trace.Stop()
```

プロファイルを表示する場合は以下

```
$ go tool trace trace.out
```

## API仕様を表示

ioutil.ReadAllの例

```
$ go doc ioutil.ReadAll
```

## ゴルーチンとスレッドの違い

goの実行環境は1個のスレッドで何個のゴルーチンを動かすかを決めている。
goのデフォルトはCPUの個数（正確には異なるが）のスレッドでゴルーチンを動かしている。

システムコールを呼び出す場合は、必ずカーネルスレッドを生成している。そうしないとシステムコールの待ちが発生してしまうため。

## チャネル

```
ch := make(chan string)
```

この場合、バッファ0のチャネルなので読み込み処理が終わるまで書き込み処理が終わらない。

```
// ゴルーチンA
fmt.Println(<-ch) // 読み込み処理
```

```
// ゴルーチンB
ch <- "foo" // 書き込み処理
```

この処理だと、必ずA->Bの順番にチャネル処理が終わる。

## godoc

godocにオプションを使うと、どのインターフェースを実装しているかを調べることができる。

```
$ godoc -analysis=type -analysis=pointer -http :8000
```

参考：p.344


## 定数は特別

```
const f = 32.0
```

定数はfloat64より高い精度の値であり、
const同士の計算も精度が高いままコンパイラが処理する。
しかし、変数に代入するタイミングで変数の精度で計算することに注意。


## ローカル変数のアドレス

ローカル変数のアドレスを返す場合、goは変数をHeapに確保する。
ローカス変数のアドレスを返さない場合、goは変数をStackに確保する。

これを内部的に行っているため、ローカル変数のアドレスを返しても安全に動作することが可能となっている。

参考：p.39


## エディタの人口

- vim 3
- emacs 5
- その他 4
